const {parentPort,workerData}=require("worker_threads"),crypto=require("crypto"),{ec}=require("elliptic"),ecInstance=new ec("secp256k1"),BASE58_ALPHABET="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",base58Encode=b=>{let n=BigInt("0x"+b.toString("hex")),e="";for(;n>0;){const r=n%58n;n/=58n,e=BASE58_ALPHABET[Number(r)]+e}for(let t=0;t<b.length&&b[t]===0;t++)e="1"+e;return e},privateKeyToAddress=h=>{const k=ecInstance.keyFromPrivate(h,"hex"),p=k.getPublic(!0,"hex"),s=crypto.createHash("sha256").update(Buffer.from(p,"hex")).digest(),r=crypto.createHash("ripemd160").update(s).digest(),v=Buffer.concat([Buffer.from([0x00]),r]),c=crypto.createHash("sha256").update(crypto.createHash("sha256").update(v).digest()).digest().slice(0,4);return base58Encode(Buffer.concat([v,c]))},getRandomKeyInRange=(s,e)=>s+BigInt("0x"+crypto.randomBytes(32).toString("hex"))%(e-s),{workerId,start,end,targetAddressPrefix}=workerData;let iterationCount=0,N=1e7;for(;;){const currentKey=getRandomKeyInRange(BigInt(start),BigInt(end)),privateKeyHex=currentKey.toString(16).padStart(64,"0"),bitcoinAddress=privateKeyToAddress(privateKeyHex);if(iterationCount++,iterationCount%N==0&&console.log(`Worker ${workerId} - Iteration ${iterationCount}: Private Key: ${privateKeyHex}, Bitcoin Address: ${bitcoinAddress}`),bitcoinAddress.startsWith(targetAddressPrefix))parentPort.postMessage({workerId,match:!0,privateKey:privateKeyHex,bitcoinAddress}),process.exit(0)}
parentPort.postMessage({workerId,match:!1});
